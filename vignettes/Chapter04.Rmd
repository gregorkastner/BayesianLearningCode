---
title: "Chapter 4: A First Bayesian Analysis of Continuous Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Chapter 4: A First Bayesian Analysis of Continuous Data}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6
)
knitr::opts_knit$set(global.par = TRUE)
pdfplots <- FALSE # default: FALSE; set this to TRUE only if you like pdf figures
```

```{r, include = FALSE}
par(mgp = c(1.6, .6, 0), mar = c(2.6, 2.6, 2.6, .4), lwd = 1)
```

# Swiss franc versus US dollar
## Example 4.1: The data

We use exchange rate data contained in  the package *stochvol*, covering the
period from January 3, 2000, until April 4, 2012. We are interested in the
percentage log returns of the the Swiss franc (CHF) against the US dollar (USD).

```{r, echo=-(1:2)}
if (pdfplots) {
  pdf("4-1_1.pdf", width = 8, height = 5)
  par(mar = c(2.2, 1.6, 1.6, .2), mgp = c(1.2, .5, 0))
}
par(mfrow = c(1, 2))
data(exrates, package = "stochvol")
y <- 100 * diff(log(exrates$USD / exrates$CHF))
hist(y, breaks = 50, main = "Histogram", xlab = "CHF/USD log returns")
ts.plot(y, main = "Time series plot", ylab = "CHF/USD log returns")
```

## Example 4.2: A first posterior

For a first joint inference on $\mu$ and $\sigma^2$, we assume a Gaussian
likelihood,
$$
p(\mathbf y|\mu,\sigma^2) = \prod_{i=1}^N p(y_i|\mu, \sigma^2)=
   \left(\frac{1}{2 \pi \sigma^2}\right)^{N/2}  \exp
\left( - \frac{1}{\sigma^2} \sum_{i=1}^{N} \frac{(y_i-\mu)^2}{2} \right).
$$

In addition, we assume the improper prior
$$
p(\mu, \sigma^2) \propto \frac{1}{\sigma^2},
$$
yielding the posterior
$$
p(\mu,\sigma^2|\mathbf y) =
f_N\left(\mu;\bar{y},\frac{\sigma^2}{N}\right)
f_{\mathcal{G}^{-1}}\left(\sigma^2;\frac{N-1}{2},\frac{N s_y^2}{2}\right).
$$
We can now plot this. Note that base R does not ship the density function of the
inverse gamma, so we define it ourselves using the transformation law of
densities. Also note that in R, the Gaussian distribution is parameterized in terms
of mean and standard deviation (not mean and variance).

```{r, echo=-(1:2)}
if (pdfplots) {
  pdf("4-1_2.pdf", width = 8, height = 5)
  par(mar = c(1.2, 2, .9, 0), xpd = NA)
} else par(mar = c(1.2, 1, .9, 0), xpd = NA)
par(mfrow = c(2, 3))
dinvgamma <- function(x, a, b, log = FALSE) {
  logdens <- dgamma(1/x, a, b, log = TRUE) - 2 * log(x)
  if (log) logdens else exp(logdens)
}

posterior <- function(mu, sigma2, ybar, s2, N) {
  dnorm(mu, ybar, sqrt(sigma2 / N)) * dinvgamma(sigma2, (N - 1) / 2, N * s2 / 2)
}

mu <- seq(-.25, .25, length.out = 30)
sigma2 <- seq(.4, .7, length.out = 30)

# Generate the desired number of colors from a palette
nbcol <- 20
color <- topo.colors(nbcol)

# Plot for different sample sizes
for (n in c(50, 100, 200, 500, 1000, length(y))) {
  ytmp <- head(y, n)
  z <- outer(mu, sigma2, posterior,
             ybar = mean(ytmp), s2 = var(ytmp) * (n - 1) / n, N = n)

  # Compute the z-values at the facet centers
  zfacet <- z[-1, -1] + z[-1, -ncol(z)] + z[-nrow(z), -1] + z[-nrow(z), -ncol(z)]

  # Recode facet z-values into color indices
  facetcol <- cut(zfacet, nbcol)

  # Perspective plot
  pmat <- persp(mu, sigma2, z, col = color[facetcol], ticktype = "detailed",
                main = paste0("N = ", n), nticks = 4, zlab = "", xlab = "",
                ylab = "", phi = 20, theta = -30, r = 100)
  
  # Add axis labels (done manually because persp() does not support expressions)
  loc <- trans3d(mean(mu) - .15 * diff(range(mu)),
                 min(sigma2) - .4 * diff(range(sigma2)),
                 0, pmat = pmat)
  text(loc$x, loc$y, expression(mu), cex = 1.3)
  
  loc <- trans3d(min(mu) - .35 * diff(range(mu)),
                 mean(sigma2) - .1 * diff(range(sigma2)),
                 0, pmat = pmat)
  text(loc$x, loc$y, expression(sigma^2), cex = 1.3)
}
```

## Example 4.3: Posterior marginals

We now want to visualize the marginals of the bivariate posterior. Note that
R does not natively cater for the generalized Student's t distribution, so
we first define its (cumulative) density and quantile functions.

```{r, echo=-(1:2)}
if (pdfplots) {
  pdf("4-1_2.pdf", width = 10, height = 8)
  par(mgp = c(1.6, .6, 0), mar = c(2, 2, 3, .5), lwd = 2)
}
par(mfrow = c(2, 2))

dstudt <- function(x, location = 0, scale = 1, df, log = FALSE) {
  logdens <- dt((x - location)/scale, df = df, log = TRUE) - log(scale)
  if (log) logdens else exp(logdens)
}

pstudt <- function(x, location = 0, scale = 1, df) {
  pt((x - location) / scale, df = df)
}

qstudt <- function(p, location = 0, scale = 1, df) {
  location + scale * qt(p, df = df)
}

N <- length(y)
location <- mean(y)
scale <- sqrt(var(y) / N)
df <- N - 1

mu <- seq(-.06, .06, length.out = 300)
plot(mu, dstudt(mu, location, scale, df), type = "l", xlab = expression(mu),
     ylab = "", main = "Posterior density and quantiles")
abline(h = 0, lty = 3)

probs <- c(0.05, .5, .95)
qs <- qstudt(probs, location, scale, df)
ds <- dstudt(qs, location, scale, df)

xpd <- par(xpd = NA)

for (i in seq_along(probs)) {
  lines(c(qs[i], qs[i]), c(-1, ds[i]), lty = 2)
  text(qs[i], -2, round(qs[i], 3), cex = .8)
}

par(xpd = FALSE)

plot(mu, pstudt(mu, location, scale, df), type = "l", xlab = "", ylab = "",
     main = "Posterior cdf and quantiles")
abline(h = c(0, 1), lty = 3)

myxlim <- par("usr")[1] - .1*diff(par("usr")[1:2])

for (i in seq_along(probs)) {
  lines(c(myxlim, qs[i]), c(probs[i], probs[i]), lty = 2)
  lines(c(qs[i], qs[i]), c(probs[i], -1), lty = 2)
}
```
